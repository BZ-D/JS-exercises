### 严格模式

#### 设计目的

严格模式是从 ES5 进入标准的，主要目的有以下几个。

- 明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。
- 增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。
- 提高编译器效率，增加运行速度。
- 为未来新版本的 JavaScript 语法做好铺垫。

总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。



#### 启用方法

`'use strict';` 可以用于整个脚本（放在整个脚本文件的第一行），也可以只用于单个函数（放在局部作用域的第一行）。



#### 显式报错

对于有些在正常模式下默默地失败的操作，在严格模式下会显式报错

- 对于只读属性，不可写。如设置字符串的 length 属性会报错
- 删除不可配置属性
- 只设置了取值器的属性不可写，即该属性只有 get 没有 set 时
- 禁止扩展的对象不可扩展，即对对象应用 `Object.preventExtensions(obj)` 时
- eval、arguments 不可用做标识名
- 函数名不得有重名参数
- 禁止八进制前缀 0 表示法



#### 增强的安全措施

- 全局变量显式声明：变量必须先声明再使用
- 禁止 this 关键字指向全局对象，使用构造函数忘记加 new 时，就会报错。普通函数直接调用时，函数内部的 this 表示 undefined，可以使用 call、apply、bind 方法进行绑定
- 禁止使用 fn.callee、fn.caller、fn.arguments，否则报错，这意味着不能在函数内部得到调用栈
- 禁止使用 arguments.callee、arguments.caller，这两个是遗留的变量，从来没有标准化过，现在已经取消了
- 禁止删除变量，正常模式下若试图用 `delete` 删除一个变量，只会默默地失败，而严格模式下会报错



#### 静态绑定

JS 语言的一个特点就是允许动态绑定，即某些属性和方法到底属于哪个对象，不是在编译时确定的，而是在运行时确定的，严格模式下对动态绑定作出限制，即某些情况下只允许静态绑定：

- 禁止使用 with 语句，因为它无法在编译时确定某个属性到底归属于哪个对象

- 创设 eval 作用域，严格模式创设了除了全局和局部作用域之外的第三种作用域——eval 作用域

  - 正常模式下，eval 语句的作用域取决于它所处的作用域

  - 严格模式下，eval 语句本身就是一个作用域，不能够再在其运行的作用域创设新的变量了，即 eval 所生成的变量只能用于 eval 内部

  - 若希望 eval 作用域中也使用严格模式，有两种方式：

    ```js
    // 方式一
    function f1(str){
      'use strict';
      return eval(str);
    }
    f1('undeclared_variable = 1'); // 报错
    
    // 方式二
    function f2(str){
      return eval(str);
    }
    f2('"use strict";undeclared_variable = 1')  // 报错
    ```

- arguments 不再追踪参数的变化：函数内部改变参数与 arguments 的联系被切断，函数内部改变参数不会反映到 arguments 对象上来



#### 向下一版本的 JavaScript 过渡

严格模式引入了一些 ES6 语法

- 非函数代码块不得声明函数
- 新增了一些保留字，如 implements、interface、let、package、private、protected、public、static、yield 等。使用这些词作为变量名将会报错。
